"""Tests for exploitability computation."""

from src.abstraction.action_abstraction import ActionAbstraction
from src.evaluation.exploitability import (
    compute_exploitability,
    compute_nash_conv,
)
from src.solver.mccfr import MCCFRSolver
from src.solver.storage import InMemoryStorage
from tests.test_helpers import DummyCardAbstraction


class TestExploitability:
    """Tests for exploitability computation."""

    def test_compute_exploitability_untrained_solver(self):
        """Test exploitability of an untrained solver (should be high)."""
        # Create solver
        action_abstraction = ActionAbstraction()
        card_abstraction = DummyCardAbstraction()
        storage = InMemoryStorage()

        solver = MCCFRSolver(
            action_abstraction,
            card_abstraction,
            storage,
            config={"starting_stack": 200, "small_blind": 1, "big_blind": 2},
        )

        # Compute exploitability with very small sample size for speed (just 10 samples)
        result = compute_exploitability(solver, num_samples=10, use_average_strategy=True)

        # Check result structure
        assert "exploitability" in result
        assert "player_0_br_utility" in result
        assert "player_1_br_utility" in result
        assert "nash_utility" in result

        # Exploitability should be a number
        assert isinstance(result["exploitability"], float)

        # For untrained solver, exploitability should be relatively high
        # (uniform random play is very exploitable)
        print(f"Untrained exploitability: {result['exploitability']:.2f} mbb/g")

    def test_compute_exploitability_trained_solver(self):
        """Test exploitability of a trained solver (should be lower)."""
        # Create solver
        action_abstraction = ActionAbstraction()
        card_abstraction = DummyCardAbstraction()
        storage = InMemoryStorage()

        solver = MCCFRSolver(
            action_abstraction,
            card_abstraction,
            storage,
            config={"starting_stack": 200, "small_blind": 1, "big_blind": 2, "seed": 42},
        )

        # Train for a few iterations
        for _ in range(1000):
            solver.train_iteration()

        # Compute exploitability with small sample
        result = compute_exploitability(solver, num_samples=10, use_average_strategy=True)

        print(f"Trained (1000 iters) exploitability: {result['exploitability']:.2f} mbb/g")

        # After training, exploitability should be a reasonable number
        assert result["exploitability"] >= 0
        assert result["exploitability"] < 1000  # Not completely random

    def test_compute_exploitability_different_strategies(self):
        """Test that average strategy and current strategy give different results."""
        # Create and train solver
        action_abstraction = ActionAbstraction()
        card_abstraction = DummyCardAbstraction()
        storage = InMemoryStorage()

        solver = MCCFRSolver(
            action_abstraction,
            card_abstraction,
            storage,
            config={"starting_stack": 200, "small_blind": 1, "big_blind": 2, "seed": 42},
        )

        # Train briefly
        for _ in range(500):
            solver.train_iteration()

        # Compute both with small samples
        avg_result = compute_exploitability(solver, num_samples=5, use_average_strategy=True)
        current_result = compute_exploitability(solver, num_samples=5, use_average_strategy=False)

        print(f"Average strategy exploitability: {avg_result['exploitability']:.2f} mbb/g")
        print(f"Current strategy exploitability: {current_result['exploitability']:.2f} mbb/g")

        # Both should be valid numbers
        assert avg_result["exploitability"] >= 0
        assert current_result["exploitability"] >= 0

    def test_nash_conv_untrained(self):
        """Test Nash convergence metric on untrained solver."""
        action_abstraction = ActionAbstraction()
        card_abstraction = DummyCardAbstraction()
        storage = InMemoryStorage()

        solver = MCCFRSolver(
            action_abstraction,
            card_abstraction,
            storage,
            config={"starting_stack": 200, "small_blind": 1, "big_blind": 2},
        )

        # Run a few iterations to populate infosets
        for _ in range(100):
            solver.train_iteration()

        # Compute Nash conv
        nash_conv = compute_nash_conv(solver)

        print(f"Nash convergence (100 iters): {nash_conv:.2f}")

        # Should be non-negative
        assert nash_conv >= 0

    def test_nash_conv_decreases_with_training(self):
        """Test that Nash convergence decreases as solver trains."""
        action_abstraction = ActionAbstraction()
        card_abstraction = DummyCardAbstraction()
        storage = InMemoryStorage()

        solver = MCCFRSolver(
            action_abstraction,
            card_abstraction,
            storage,
            config={"starting_stack": 200, "small_blind": 1, "big_blind": 2, "seed": 42},
        )

        # Train and measure Nash conv at intervals
        for _ in range(100):
            solver.train_iteration()
        nash_conv_early = compute_nash_conv(solver)

        for _ in range(900):
            solver.train_iteration()
        nash_conv_late = compute_nash_conv(solver)

        print(f"Nash conv early (100 iters): {nash_conv_early:.2f}")
        print(f"Nash conv late (1000 iters): {nash_conv_late:.2f}")

        # Nash convergence might not strictly decrease due to CFR+ and sampling,
        # but both should be finite
        assert nash_conv_early >= 0
        assert nash_conv_late >= 0
