"""Tests for exploitability computation."""

import pytest

from src.actions.betting_actions import BettingActions
from src.evaluation.exploitability import compute_exploitability
from src.solver.mccfr import MCCFRSolver
from src.solver.storage.shared_array import SharedArrayStorage
from tests.test_helpers import DummyCardAbstraction, make_test_config


class TestExploitability:
    """Tests for exploitability computation."""

    def test_compute_exploitability_untrained_solver(self):
        """Test exploitability of an untrained solver (should be high)."""
        # Create solver
        action_abstraction = BettingActions()
        card_abstraction = DummyCardAbstraction()
        storage = SharedArrayStorage(
            num_workers=1, worker_id=0, session_id="test", is_coordinator=True
        )

        solver = MCCFRSolver(
            action_abstraction,
            card_abstraction,
            storage,
            config=make_test_config(starting_stack=200, small_blind=1, big_blind=2),
        )

        # Compute exploitability with very small sample size for speed (just 10 samples)
        result = compute_exploitability(solver, num_samples=10, use_average_strategy=True)

        # Check result structure
        assert "exploitability_mbb" in result
        assert "player_0_br_utility" in result
        assert "player_1_br_utility" in result

        # Exploitability should be a number
        assert isinstance(result["exploitability_mbb"], float)

        # For untrained solver, exploitability should be relatively high
        # (uniform random play is very exploitable)
        print(f"Untrained exploitability: {result['exploitability_mbb']:.2f} mbb/g")

    @pytest.mark.slow
    @pytest.mark.timeout(20)
    def test_compute_exploitability_trained_solver(self):
        """Test exploitability of a trained solver (should be lower)."""
        # Create solver
        action_abstraction = BettingActions()
        card_abstraction = DummyCardAbstraction()
        storage = SharedArrayStorage(
            num_workers=1, worker_id=0, session_id="test", is_coordinator=True
        )

        solver = MCCFRSolver(
            action_abstraction,
            card_abstraction,
            storage,
            config=make_test_config(starting_stack=200, small_blind=1, big_blind=2, seed=42),
        )

        for _ in range(5):
            solver.train_iteration()

        # Compute exploitability with small sample
        result = compute_exploitability(solver, num_samples=1, use_average_strategy=True)

        exploitability = result["exploitability_mbb"]
        assert isinstance(exploitability, (float, int))
        print(f"Trained (30 iters) exploitability: {exploitability:.2f} mbb/g")

        # After training, exploitability should be a reasonable number
        # Relaxed threshold since we're training less
        assert exploitability >= 0
        assert exploitability < 50000  # Very loose bound for minimal training

    @pytest.mark.slow
    @pytest.mark.timeout(20)
    def test_compute_exploitability_different_strategies(self):
        """Test that average strategy and current strategy give different results."""
        # Create and train solver
        action_abstraction = BettingActions()
        card_abstraction = DummyCardAbstraction()
        storage = SharedArrayStorage(
            num_workers=1, worker_id=0, session_id="test", is_coordinator=True
        )

        solver = MCCFRSolver(
            action_abstraction,
            card_abstraction,
            storage,
            config=make_test_config(starting_stack=200, small_blind=1, big_blind=2, seed=42),
        )

        for _ in range(15):
            solver.train_iteration()

        # Compute both with minimal samples
        avg_result = compute_exploitability(solver, num_samples=1, use_average_strategy=True)
        current_result = compute_exploitability(solver, num_samples=1, use_average_strategy=False)

        avg_exploitability = avg_result["exploitability_mbb"]
        current_exploitability = current_result["exploitability_mbb"]
        assert isinstance(avg_exploitability, (float, int))
        assert isinstance(current_exploitability, (float, int))
        print(f"Average strategy exploitability: {avg_exploitability:.2f} mbb/g")
        print(f"Current strategy exploitability: {current_exploitability:.2f} mbb/g")

        # Both should be valid numbers
        assert avg_exploitability >= 0
        assert current_exploitability >= 0
